---
title: MySQL-锁
author: 饼铛
tags:
  - MySQL
  - 锁
categories:
  - DBA
cover: /images/img-71.png
abbrlink: 28583
date: 2020-04-11 22:47:00
---
### 1.锁
#### 1.1什么是“锁”？
- “锁”顾名思义就是锁定的意思。
- “锁”的作用是什么？
- 在事务ACID过程中，“锁”和“隔离级别”一起来实现“I”隔离性的作用。
- 避免争抢资源

**锁的粒度：**
- 1、MyIasm：低并发锁——表级锁
- 2、Innodb：高并发锁——行级锁

#### 1.2InnoDB锁级别
- 行级锁
 - Next lock下键锁
 - GAP lock 间隙锁
- 悲观锁:排他性，不能不能同时修改同一行数据
- 乐观锁
- 行级锁，谁先操作某个数据行，就会持有<这行>的<x>锁

#### 1.3扩展内容
- Next lock下键锁
- GAP Lock间隙锁

#### 1.4为何出现锁等待/死锁等情况：交叉的事务出现，导致的
##### 1.锁等待
事务1：状态未提交
![事务1](/images/img-61.png)
事务2：一同更新同一行数据，会出现锁等待
![事务2](/images/img-62.png)
##### 死锁：事务交叉，互相依赖造成死锁
![事务交叉](/images/img-63.png)

#### 1.5四种隔离级别
```bash
READ UNCOMMITTED        
　　允许事务查看其他事务所进行的未提交更改
READ COMMITTED
   允许事务查看其他事务所进行的已提交更改//屏蔽脏读，会出现不可重复读。和幻读现象
REPEATABLE READ******
   确保每个事务的 SELECT 输出一致 
　　InnoDB 的默认级别
SERIALIZABLE
   将一个事务的结果与其他事务完全隔离

mysql> show variables like '%iso%';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
```

**脏读：** 所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
即，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。

---
**不可重复读：**事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。

即，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。

---
**幻读：**事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。

即，当前事务读第一次取到的数据比后来读取到数据条目少。

---
不可重复读和幻读比较：
两者有些相似，但是前者针对的是update或delete，后者针对的insert。
